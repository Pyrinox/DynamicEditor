import * as React from 'react';
interface InjectedProps {
    getRef: React.RefObject<HTMLElement>;
}
interface InteractProps {
    draggable?: Interact.DraggableOptions | boolean;
    resizable?: Interact.ResizableOptions | boolean;
    gesturable?: Interact.ResizableOptions | boolean;
    dropzone?: Interact.DropzoneOptions | boolean;
    onDragStart?: Interact.ListenersArg;
    onDragMove?: Interact.ListenersArg;
    onDragEnd?: Interact.ListenersArg;
    onResizeStart?: Interact.ListenersArg;
    onResizeMove?: Interact.ListenersArg;
    onResizeInertiaStart?: Interact.ListenersArg;
    onResizeEnd?: Interact.ListenersArg;
    onGestureStart?: Interact.ListenersArg;
    onGestureMove?: Interact.ListenersArg;
    onGestureEnd?: Interact.ListenersArg;
    onDropActivate?: Interact.ListenersArg;
    onDropdEactivate?: Interact.ListenersArg;
    onDragEnter?: Interact.ListenersArg;
    onDragLeave?: Interact.ListenersArg;
    onDropMove?: Interact.ListenersArg;
    onDrop?: Interact.ListenersArg;
    onDown?: Interact.ListenersArg;
    onMove?: Interact.ListenersArg;
    onUp?: Interact.ListenersArg;
    onCancel?: Interact.ListenersArg;
    onTap?: Interact.ListenersArg;
    onDoubleTap?: Interact.ListenersArg;
    onHold?: Interact.ListenersArg;
}
declare const reactable: <BaseProps extends InjectedProps>(BaseComponent: React.ComponentType<BaseProps>) => {
    new (props: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>): {
        interactable: import("@interactjs/core/Interactable").Interactable;
        node: React.RefObject<any>;
        componentDidMount(): void;
        componentWillUnmount(): void;
        baseProps(props: any): any;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>) => {} | Pick<{}, K>) | Pick<{}, K>, callback?: () => void): void;
        forceUpdate(callBack?: () => void): void;
        readonly props: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps, context?: any): {
        interactable: import("@interactjs/core/Interactable").Interactable;
        node: React.RefObject<any>;
        componentDidMount(): void;
        componentWillUnmount(): void;
        baseProps(props: any): any;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>) => {} | Pick<{}, K>) | Pick<{}, K>, callback?: () => void): void;
        forceUpdate(callBack?: () => void): void;
        readonly props: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Pick<BaseProps, import("utility-types").SetDifference<keyof BaseProps, "getRef">> & InteractProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    displayName: string;
    contextType?: React.Context<any>;
};
export default reactable;
